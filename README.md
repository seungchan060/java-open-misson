# 오픈 미션: 자바로 만든 작은 턴제 전략 게임

## 0. 이 프로젝트 한 줄 소개
> **"중학교때 처음 시작한 게임 모드 제작 경험과, 우테코 프리코스를 통해 처음 접한 자바를 연결해서 만든 턴제 전술 시뮬레이션 게임"**

- **언어**: Java 21  
- **빌드 도구**: Gradle  
- **실행 방식**: CLI 기반 콘솔 게임  
- **핵심 컨셉**:
  - 5x4 보드 위에서 **다수 vs 다수**가 싸우는 턴제 전술 게임
  - 기사 / 마법사 / 도적 / 궁수 / 탱커 / 수도승 등 직업별 **역할(Role) 시스템**
  - 은신, 도발, 보호막, 버프, 바디블록 등의 **시너지 스킬**
  - **리쿠르팅(영입) & 벤치 시스템** + 턴 수에 따른 피로도, 승패 규칙
  - 단순한 랜덤이 아니라 **위협 기반(Threat 기반) AI + 포커스 파이어**로 움직이는 적

---

## 1. 나의 배경과 이 미션의 목표

### 1.1 프로그래밍과의 첫 만남 – 중학교 2학년, 게임 모드 제작

- 저는 중학교 2학년때 처음으로 **게임 모드 제작**을 하면서 프로그래밍을 접했습니다.
- 제가 생각하고 원하는 것들을 만들 수 있다는 재미와
- 제가 만든 기능들을 유저가 재밌게 플레이 하는 모습을 보며 흥미를 느꼈습니다.
- 그때는 언어 자체의 깊은 이해보다는  
  - "어디를 고치면 기능이 바뀌지?"
  - "여기 숫자 바꾸면 오브젝트 및 확률이 더 많이 나오네?"
  - 특정한 기능을 만들고 싶다면 모드 제작자들에게 연락하여 배우고

  이런 식으로 **직관적으로 프로그래밍을 접했습니다.**

그 경험 덕분에,
- "코드로 게임의 룰을 정의한다"
- "규칙을 바꾸면 플레이 경험이 바뀐다"

이 두 가지에 항상 관심이 있었습니다.

### 1.2 우테코 프리코스와 자바와의 첫 만남

- 이번 우테코 프리코스를 통해 **자바를 처음 접했습니다.**
- 프리코스 동안 주어진 미션들을 따라가면서
  - 자바 문법
  - 클래스/메서드 구조
  - 패키지 구조
  - JUnit과 테스트를 조금씩 익혔습니다.

저는 지금까지 프로그래밍 언어 습득을 "**아무것도 모르더라도 일단 내가 만들어보고 싶은거, 재밌어 보이는거를 그냥 만들어보면서 배우는 학습**"을 많이 했습니다.

그래서 이번 **오픈 미션** 주제를 내가 제일 좋아하는거와 프리코스에 들어온 목적 (Java 언어 습득) 이 두가지를 연결하여 `턴제 게임`을 만들어보자고 생각하였습니다.

**내가 스스로 설계하고 만들어 보는 경험**이 성장에 많은 도움이 될거라고 생각하였습니다.

그래서 **오픈 미션**을 다음처럼 정의했습니다.

> "내가 프로그래밍을 처음 접하게 해준 ‘게임’이라는 주제와,  
> 우테코 프리코스를 통해 처음 배운 ‘자바’를 연결해서  
> 자바로 ‘내 턴제 게임’을 직접 설계하고 구현해보자."

### 1.3 이 프로젝트에서 세운 나의 목표

1. **결과물보다 과정을 중요하게 생각하기**
   - "대충 돌아가는 게임"을 만드는 게 아니라,  
   - 설계 → 구현 → 리팩토링 → 테스트까지 **"왜 이렇게 설계했는지 설명 가능"한 수준**을 목표로 했다.

2. **자바 언어 자체를 깊게 경험하기**
   - 클래스, enum, 불변 객체, 패키지 구조, 서비스/도메인 분리 등  
   - 자바다운 구조를 직접 만들어보는 경험

3. **테스트의 힘을 몸으로 느끼기**
   - 스킬/AI/룰이 복잡해질수록 사람이 직접 테스트하는 게 불가능해진다.
   - JUnit + AssertJ로 "**버그를 단위 테스트가 잡아주는 경험**"을 목표로 했다.

4. **게임 규칙을 직접 설계하고, 밸런싱 고민까지 해보기**
   - 맵 크기, 체력, 공격력, 스킬 수치, 리쿠르팅 주기, 피로도, 최대 턴 수 등  
   - 작은 숫자 하나가 플레이를 얼마나 바꾸는지 직접 체감하고 싶었다.

---

## 2. 게임 개요 – 규칙/세계관/플레이 방식

### 2.1 전체적인 느낌

- 장르: **간단한 SRPG / Tactics / Auto Chess 느낌의 턴제 전략 게임**
- 플레이어와 적이 같은 보드 위에 유닛을 배치하고,  
  **각 턴마다 1명의 아군을 조작하여 이동/공격/스킬 사용**을 한다.
- 적은 AI가 자동으로 움직인다.
  - 도발된 유닛을 우선 타겟팅
  - 힐러/딜러(수도승/마법사/궁수)를 먼저 노리는 Threat 기반
  - 은신 중인 유닛은 무시
  - 전장 상황에 맞게 포커스 파이어(집중 공격) 시도

### 2.2 맵 / 보드

- **Board**
  - 기본 크기: `5 x 4` (가로 5, 세로 4)
  - 좌표:
    - `x`: 0 ~ width-1 (좌→우)
    - `y`: 0 ~ height-1 (위→아래)

- **진영 구분**
  - **적(ENEMY)**: 위쪽 2줄 (y = 0, 1)
  - **플레이어(PLAYER)**: 아래쪽 2줄 (y = height-2, height-1)

- **초기 배치**
  - 게임 시작 때마다 **랜덤으로 유닛을 구성 & 랜덤 위치 배치**
  - **중복 위치는 허용하지 않음**


### 2.3 유닛 / 직업(Role) / 스탯

각 유닛은 다음 정보로 구성된다.

- `name`: 유닛 이름 (세계관/캐릭터 설정)
- `role`: 역할(Role)
- `side`: 팀 (PLAYER / ENEMY)
- `Stats`: HP, ATK, DEF, ARMOR, MP
- `position`: 보드 상의 위치
- 상태:
  - 은신(stealth)
  - 도발(taunt)
  - 바디블록(body block)
  - 발로어(Valor – 공격력/피해 감소 버프)
  - 실드(Shield – 보호막)
  - 스킬 쿨다운


#### 역할(직업) 요약

| Role   | 설명                               | 특징 스킬/역할                             |
|--------|------------------------------------|--------------------------------------------|
| KNIGHT | 전통적인 근접 딜/탱 혼합           | 기본기 위주, 안정적인 전투                 |
| MAGE   | 광역 딜러                          | 여러 유닛을 동시에 타격하는 스킬           |
| ROGUE  | 높은 단일 딜, 포지셔닝 중요        | 은신, 백스탭(뒷치기 보너스)                |
| ARCHER | 원거리 딜러                        | 사거리 유리, 뒤에서 안정적으로 딜링        |
| TANK   | 팀을 위한 방패                     | 도발(Taunt), 바디블록(BodyBlock)           |
| MONK   | 지원/힐/버프                       | 실드(Shield), Valor(용기 버프)             |

각 Role은 하나 이상의 Skill을 가진다.  
스킬은 `mpCost`, `cooldown`, `canUse`, `use` 로 구성된 행동 객체이다.

### 2.4 턴 구조

하나의 턴은 다음 순서로 진행된다.

1. **플레이어 턴**
   - 보드 + 유닛 상태 출력
   - 플레이어는 **아군 유닛 1명을 선택**
   - 행동 선택
     - `move` : W/A/S/D 방향으로 한 칸 이동
     - `atk`  : 인접한 적 한 명을 공격
     - `skill`: 해당 역할의 스킬 목록 중 하나를 선택해 사용

2. **적 턴 (Enemy AI)**
   - AI는 적 유닛들 중 1명을 골라 행동
   - 행동
     - 도발 대상 유닛이 있으면 → 그 유닛에게 다가가거나 공격
     - 아니면 ThreatPolicy 기반으로 타겟 선정 → 접근/공격

3. **턴 종료 처리**
   - 피로도 적용
   - 모든 유닛의 상태 감소
     - 스킬 쿨다운 감소
     - 은신/도발/바디블록/Valor/실드 지속 턴 감소

4. **3턴마다 리쿠르팅(영입)**
   - 플레이어는 새로운 유닛을 하나 "가챠"처럼 뽑을 수 있음
   - 벤치(Bench)에 추가 / 필요하면 기존 벤치에서 교체
   - 즉시 전장에 배치할 수도 있음 (규칙을 지키는 위치에 한해서)

### 2.5 승패 조건 / 피로도 / 최대 턴

- **즉시 승리**
  - 적 유닛이 모두 사망하면 플레이어 승리

- **즉시 패배**
  - 아군 유닛이 모두 사망하면 플레이어 패배

- **최대 턴 수**
  - `VictoryRule`에서 최대 턴 수를 제한 (예: 20턴)
  - 턴 수가 초과되면 남은 유닛의 HP 등을 기준으로 승패 판단

- **피로도(Fatigue)**
  - 턴이 길어지면, 모든 유닛에게 **추가 피해(HP 감소)** 를 주는 규칙
  - 예:
    - 10턴 이후 → 모든 생존 유닛 HP -5
    - 15턴 이후 → HP -10 …
  - 게임이 끝없이 늘어지지 않도록 하는 장치이기도 하고,  
    "시간이 지날수록 점점 위험해지는 (자기장)" 느낌을 주는 장치이다.

---

## 3. 설계(Architecture) – 패키지/레이어 구조

### 3.1 전체 패키지 구조

```text
src/main/java
└─ game
   ├─ app
   │   └─ GameApplication.java    # 진입점(main)
   ├─ cli
   │   ├─ InputView.java          # 사용자 입력
   │   └─ OutputView.java         # 보드/상태 출력
   ├─ core
   │   ├─ board
   │   │   ├─ Board.java
   │   │   └─ Position.java
   │   ├─ entity
   │   │   ├─ Unit.java
   │   │   ├─ Role.java
   │   │   ├─ Stats.java
   │   │   ├─ TeamSide.java
   │   │   └─ (상태 관련 메서드들: 은신/도발/실드 등)
   │   ├─ skill
   │   │   ├─ Skill.java          # 인터페이스/추상 스킬
   │   │   ├─ Backstab.java
   │   │   ├─ SmokeBomb.java
   │   │   ├─ Taunt.java
   │   │   ├─ BodyBlock.java
   │   │   ├─ Shield.java
   │   │   └─ Valor.java
   │   ├─ rules
   │   │   ├─ VictoryRule.java
   │   │   └─ FatigueRule.java
   │   ├─ service
   │   │   ├─ MovementService.java
   │   │   ├─ AttackService.java
   │   │   ├─ EnemyAiService.java
   │   │   ├─ ThreatPolicy.java
   │   │   └─ RecruitService.java
   │   ├─ bench
   │   │   └─ Bench.java
   │   └─ engine
   │       └─ BattleEngine.java   # 게임 진행 메인 엔진
   └─ (기타 보조 클래스들)
```

### 3.2 레이어링 컨셉

- **app 레이어**
    - 실행 진입점만 담당 (`main`)
    - 보드 생성, 초기 유닛 세팅, 엔진 실행
- **core.entity**
    - 게임의 "명사"에 해당하는 것들
        - Unit, Role, Stats, TeamSide
    - 가능하면 **상태와 행동을 함께 두되**,
        
        너무 복잡한 로직(예: 경로 탐색, AI)은 service로 분리
        
- **core.board**
    - 좌표/보드 영역에 대한 책임
    - Position, Board
    - `isInside` / `manhattanDistance` 등 수학적인 책임
- **core.skill**
    - 각 직업 스킬에 대한 행동 정의
    - 공통 인터페이스 `Skill`를 통해 다형성 구현
- **core.rules**
    - 승리 조건, 피로도 조건 등에 대한 규칙
    - 게임 시스템과 분리해서, 필요하면 나중에 다른 룰을 추가하기 쉽게 설계
- **core.service**
    - 구체적인 "행동 로직"을 담는 서비스
        - MovementService: 이동 가능 여부 확인, 실제 이동 처리
        - AttackService : 공격 시 데미지 계산, 방어, 실드, 버프 처리 순서 관리
        - EnemyAiService : 적 AI 의사결정
        - ThreatPolicy : 타겟 선택 로직
        - RecruitService : 리쿠르팅/유닛 생성 로직
- **core.engine**
    - BattleEngine: 턴 순서/입력 흐름/각 시스템 호출을 조합
- **cli**
    - View/Controller에 가까운 역할
    - InputView / OutputView로 UI 로직을 분리함

---

## 4. 구현 중 설계가 바뀐 지점들 + 그 이유

### 4.1 "한 턴에 몇 명이 행동하나?" – 모든 유닛 vs 1 유닛

초기 설계에서는

- "한 턴에 모든 아군이 한 번씩 행동"
- "그 다음 한 턴에 모든 적이 한 번씩 행동"

을 생각했다.

하지만 실제로 구현을 시작하고 CLI로 플레이해보니,

- 콘솔 입력이 너무 많아져서 피로도가 컸고
- **"한 번의 선택"의 무게감이 떨어진다**는 느낌이 들었다.
- 테스트도 복잡해짐 (한 턴에 여러 유닛 행동을 순서대로 모두 검증해야 해서)

그래서 방향을 바꿨다.

> 한 턴에 아군 1명만 행동, 그 다음 적 1명만 행동
> 

이렇게 바꾸니

- 플레이어의 한 번 선택이 훨씬 무겁게 느껴지고
- 테스트에서도 "플레이어 → EnemyAi 한 번 호출 → 결과 검증" 흐름이 단순해졌다.
- 나중에 원한다면 "한 턴에 N명 행동" 같은 설정도 추가할 수 있도록 엔진을 확장 가능한 형태로 유지했다.

### 4.2 스킬/피해 처리 순서 – Shield, BodyBlock, Valor, DEF

실제 전투 게임에서 중요한 것 중 하나가 **"피해 처리 순서"** 이다.

처음에는 단순히

- 공격력 ATK
- 방어력 DEF
- 체력 HP

만 두고 `hp -= max(1, atk - def)` 정도로 처리했었다.

하지만 스킬이 늘어나면서 다음과 같은 질문이 생겼다.

- 보호막(Shield)이 있을 때
    - `Shield` → `DEF` 순서인가?
    - 아니면 `DEF` → `Shield`인가?
- 바디블록(BodyBlock)은 어느 시점에 개입하나?
- Valor 버프(피해 감소)는 언제 적용해야 직관적인가?

여기서 **테스트가 정말 큰 역할**을 했다.

- "Shield가 피해를 먼저 흡수해야 한다"는 테스트
- "Valor 피해 감소 후, DEF까지 적용" 같은 테스트

이런 테스트를 먼저 적어놓고, 코드가 테스트를 통과하도록 구현을 조정하면서

"**내가 원하는 전투 규칙이 정확히 무엇인지**"를 스스로 발견하게 되었다.

결론적으로

1. BodyBlock(탱커가 몸으로 막는 효과)이 먼저 개입할 수 있고
2. Shield(보호막)가 피해를 우선 흡수
3. 남은 피해에 대해 Valor의 피해 감소를 적용
4. 마지막으로 DEF를 적용, 그 후 HP 차감

이런 순서를 정리했다.

### 4.3 Shield의 "지속 여부"와 테스트의 충돌

Shield 구현에서 한 번 큰 삽질을 했다.

- 처음에는 **쉴드량이 0이 되면 바로 "없어졌다"** 고 판단해서
    
    `hasShield()`를 `shieldAmount > 0` 기준으로 구현했다.
    
- 하지만 테스트에서는
    - 쉴드가 이미 다 깎여도,
    - **해당 턴이 끝나기 전까지는 "쉴드 버프"가 남아있다고 간주**
    - 즉, "버프 지속 턴"이 더 중요했다.

테스트가 계속 실패하면서

"내가 머릿속으로 생각한 규칙"과

"테스트가 검증하고 있는 실제 규칙"이 다르다는 걸 깨닫고,

다음처럼 다시 정리했다.

- **Shield의 존재 여부**: `shieldTurnRemaining > 0`
- **남은 양**은 0일 수 있어도 "쉴드 버프"는 턴이 끝나야 떨어진다.

이렇게 바꾼 뒤, 테스트와 실제 플레이 모두 직관적으로 맞아떨어졌다.

### 4.4 Enemy AI – 처음엔 단순, 나중엔 위협 기반 + 포커스 파이어

초기 Enemy AI는 아주 단순했다.

- "가장 가까운 플레이어에게 다가간다."
- "인접해 있으면 공격한다."

하지만 스킬 시스템이 복잡해지고 나니,

이 정도로는 게임이 전혀 재밌지 않았다.

그래서 다음과 같은 고민을 했다.

- 탱커가 도발을 쓰면, 적이 정말 날 보고 와야 한다.
- 힐러/버퍼(수도승)를 내버려 두면 안 되고, AI가 이것도 고려해야 한다.
- 은신(스모크밤)은 "타겟팅 불가"라는 느낌이 나야 한다.
- 두 적이 서로 다른 유닛을 치는 것보다,
    
    **한 유닛을 집중해서 잡는 포커스 파이어가 플레이 경험상 더 강한 긴장감을 준다.**
    

이 고민을 코드로 풀기 위해 `ThreatPolicy` + `EnemyAiService` 구조를 만들었다.

- ThreatPolicy
    - 도발 상태면 점수 +10000
    - MONK/MAGE/ARCHER는 높은 Threat 점수
    - TANK는 오히려 낮은 점수
    - 스텔스 상태면 후보에서 제외
    - Shield/Valor가 있으면 살짝 감점
- EnemyAiService
    - 도발 대상이 있으면 무조건 그쪽을 타겟팅
    - 아니면 ThreatPolicy로 타겟 선정
    - 이전 포커스 타겟이 유효하면 계속 유지(포커스 파이어)
    - 직선 경로가 막혀 있으면, 우회 경로를 찾는다 (Detour)

이 구현 과정에서도 여러 번 테스트가 깨졌는데,

- "스텔스 유닛은 무시되어야 한다" 테스트
- "도발 대상이 아닌 인접 유닛은 공격하면 안 된다" 테스트
- "디툴 상황에서 적은 막고 있는 유닛이 아니라 그냥 우회해야 한다" 테스트

같은 것들을 통과시키면서

**AI 의사결정을 꽤 정교하게 만들 수 있었다.**

---

## 5. 자바를 처음 배우면서 얻은 것들

### 5.1 언어 문법 + 객체지향 감각

- 클래스/필드/메서드 정의
- `final`과 불변성
- `enum`(Role, TeamSide 등)
- 패키지 구조 분리
- `List`, `Stream` 등을 통한 컬렉션 처리
- `record` 대신 클래스를 유지하면서도
    
    "값 객체처럼" 쓰기 위해 `Position`을 불변으로 만든 점
    

### 5.2 책임 분리 경험

- 처음에는 `BattleEngine`에 거의 모든 로직을 넣으려고 했다.
- 그러다 보니
    - 이동, 공격, AI, 스킬, 승리 조건이 한 클래스에 섞이면서
    - 읽기도 힘들고 테스트도 어렵고, 수정도 위험했다.

그래서 분리했다.

- 이동 관련 👉 `MovementService`
- 공격/피해 관련 👉 `AttackService`
- 승리/피로 👉 `VictoryRule`, `FatigueRule`
- AI 전체 👉 `EnemyAiService`, `ThreatPolicy`
- 입력/출력 👉 `InputView`, `OutputView`
- 도메인 모델 👉 `Unit`, `Stats`, `Board`, `Position`, `Role`

이 과정에서 "**클래스 하나당 역할을 좁게 잡는 것**"이

코드를 얼마나 읽기/수정하기 쉽게 만드는지 배웠다.

### 5.3 테스트의 힘

이 프로젝트에서 가장 크게 배운 것 중 하나가 **테스트의 힘**이다.

- 눈으로 게임을 돌리면서 확인하는 것만으로는,
    
    **AI/SKILL/룰이 정말로 내가 의도한 대로 동작하는지**를 보장할 수 없다.
    
- 단위 테스트를 통해
    - 이 상황에서, 이 HP/MP/버프 조합이면,
        
        이렇게 줄어야 한다는 규칙을 직접 코드로 적어두었고,
        
    - 구현을 바꿔도 테스트가 깨지지 않으면 "안전하다"는 자신감이 생겼다.
    - 반대로, 내가 잘못 설계했거나 놓친 부분이 있으면 테스트가 잡아줬다.

---

## 6. 구현 로드맵 & 실제 진행 순서

### 6.1 초기 로드맵

처음 머릿속에 그렸던 로드맵은 다음과 같았다:

1. **Step 0 – 환경 구축**
    - IntelliJ + Gradle 프로젝트 생성
    - JDK 21 설정
2. **Step 1 – 최소한의 전장/유닛**
    - Board/Position 정의
    - Unit/Stats/Role/TeamSide 기본 정의
    - CLI로 보드 출력
3. **Step 2 – 이동/공격**
    - 유닛 한 개만 두고 이동/공격 로직 작성
    - 사거리 1 공격, 보드 밖/겹침 처리
4. **Step 3 – 턴 시스템**
    - 플레이어 턴 → 적 턴 → 반복
    - 간단한 Enemy AI
5. **Step 4 – 직업(Role) 분화**
    - Knight, Mage, Rogue, Archer, Tank, Monk 역할을 도메인에 정의
6. **Step 5 – 스킬 시스템 기본**
    - Skill 인터페이스/추상 클래스
    - 스킬 1개부터 시작해서 점점 늘리기
7. **Step 6 – 승리/피로/최대 턴**
    - VictoryRule, FatigueRule
8. **Step 7 – 리쿠르팅/벤치**
    - Bench, RecruitService
    - 3턴마다 리쿠르팅
9. **Step 8 – 스킬 고도화**
    - Rogue: Stealth/Backstab
    - Tank: Taunt/BodyBlock
    - Monk: Shield/Valor
10. **Step 9 – Enemy AI 고도화**
    - ThreatPolicy
    - 포커스 파이어
    - 스텔스/도발 인식
    - 디툴
11. **Step 10 – 랜덤 파티 & 랜덤 배치**
    - Blueprint 기반 유닛 생성
    - PLAYER/ENEMY 초기 조합 랜덤 구성
12. **Step 11 – README/회고 작성**

### 6.2 실제 구현하면서 추가/수정된 부분

실제 진행하면서는

- **Step 3~4**에서 턴 설계가 크게 바뀌었고,
- **Step 5~8**에서 계속해서 스킬/피해 처리/상태 시스템이 진화했으며,
- **Step 9**에서 Enemy AI 설계가 두어 번 갈아엎어지기도 했다.

이때마다 "설계 문서를 고치는 느낌"으로 README 내용도 머릿속에서 수정해갔고,

단위 테스트를 추가하면서 설계 변경을 안전하게 가져갈 수 있었다.

---

## 7. 어떻게 실행하나요?

### 7.1 Gradle로 실행

```bash
./gradlew run
```

혹은 IntelliJ에서

- `GameApplication.main()` 을 Run Configuration으로 실행

### 7.2 플레이 방법 요약

1. 프로그램 실행 시, 보드와 유닛 상태가 출력된다.
2. **플레이어 턴**
    - `행동할 아군 유닛 좌표 (예: 2,3) 또는 exit:`
        
        → 예: `2,3` 입력
        
    - `행동 (move / atk / skill):`
        - `move` 선택 시: `방향 (W/A/S/D):`
        - `atk` 선택 시: `공격 대상 좌표 (예: 2,1):`
        - `skill` 선택 시:
            - 스킬 목록 출력 → 번호 입력 → 대상 좌표 입력(또는 자기 대상은 빈 엔터)
3. **적 턴**
    - AI가 자동으로 행동 (로그로 확인)
4. 턴이 진행될수록
    - 피로도 로그,
    - 리쿠르팅 이벤트,
    - 승리/패배 로그가 나타난다.

---

## 8. 테스트(단위 테스트) 구조와 의도

**설계를 검증하고, 규칙을 문서화하는 도구**

### 8.1 테스트 실행 방법

```bash
./gradlew test
```

IntelliJ에서는 `test` 소스셋의 각 테스트 클래스를 개별 실행할 수도 있다.

---

### 8.2 테스트 패키지 구조 개요

```
src/test/java
└─ game
   └─ core
      ├─ entity
      │   └─ StatsTest.java
      ├─ rules
      │   ├─ VictoryRuleTest.java
      │   └─ FatigueRuleTest.java
      ├─ service
      │   ├─ MovementServiceTest.java
      │   ├─ AttackServiceTest.java
      │   ├─ HealShieldAbsorbTest.java
      │   ├─ SupportSynergyTest.java
      │   ├─ EnemyAiStealthTest.java
      │   ├─ EnemyAiStealthIgnoreTest.java
      │   ├─ EnemyAiTauntTest.java
      │   ├─ EnemyAiTauntPriorityTest.java
      │   ├─ EnemyAiFocusFireTest.java
      │   ├─ EnemyAiHealerPriorityTest.java
      │   └─ EnemyAiDetourMoveTest.java
      └─ (기타 유틸/도메인 테스트)

```

(실제 클래스 이름은 약간 다를 수 있지만, 대략 이런 느낌으로 나뉘어 있다.)

---

### 8.3 Stats / Rules 계열 테스트

### `StatsTest`

- **목적**: `Stats`가 데미지/방어/체력에 대해 "내가 정의한 규칙"대로 동작하는지 검증
- 예시 시나리오:
    - 방어력이 공격보다 높아도, 최소 1 이상 피해가 들어가는지
    - HP가 0 이하로 내려가면 `isDead()`가 true인지
    - MP가 부족할 때 스킬 사용이 막히는지
- 이 테스트를 통해 **"숫자 계산에서 발생할 수 있는 사소한 실수"** 를 먼저 제거했다.

### `VictoryRuleTest`

- **목적**: 승리/패배/무승부 조건이 정확히 맞는지 확인
- 검증 내용:
    - 적이 모두 죽었을 때 PLAYER 승리
    - 플레이어가 모두 죽었을 때 패배
    - 최대 턴 수를 초과했을 때, 양쪽 유닛 HP를 비교해 승/패/무승부 판정이 올바른지
- 이 테스트 덕분에, VictoryRule을 수정해도 "이겼다/졌다" 판단이 바뀌지 않는다는 확신을 가질 수 있었다.

### `FatigueRuleTest`

- **목적**: "턴이 길어질수록 피로도로 인해 HP가 줄어든다"는 규칙 검증
- 검증 내용:
    - 특정 턴 수 이전에는 피로도가 적용되지 않는지
    - 턴 10, 15 이후에 정해진 만큼의 HP 감소가 발생하는지
- 이 테스트는 **게임이 끝없이 길어지지 않도록 설계한 규칙**이 잘 작동하는지를 보장한다.

---

### 8.4 Movement / Attack / 시너지 계열 테스트

### `MovementServiceTest`

- **목적**: 이동 관련 로직이 보드 범위/충돌을 올바르게 처리하는지 확인
- 검증 내용:
    - 보드 밖으로 나가려고 하면 이동 실패
    - 다른 유닛이 있는 칸으로는 이동할 수 없음
    - 정상적인 한 칸 이동이 성공했을 때, 좌표가 정확히 바뀌는지

### `AttackServiceTest`

- **목적**: 기본 공격이 Stats/DEF를 활용해 올바르게 피해를 입히는지 검증
- 검증 내용:
    - 공격 후 HP 감소량
    - 최소 피해 1 보장
    - 사망 처리 여부

### `HealShieldAbsorbTest`

- **목적**: 실드(Shield)가 HP보다 먼저 닳는지, 즉 "보호막 → HP 순서"가 맞는지 검증
- 시나리오:
    - HP 20, Shield 12인 상태에서 데미지 10을 두 번 받았을 때
    - 첫 번째 공격에서 Shield만 깎이고 HP는 그대로인지
    - 두 번째 공격에서 남은 Shield + HP가 올바르게 줄어드는지

### `SupportSynergyTest`

- **목적**: BodyBlock, Shield, Valor가 동시에 켜져 있을 때 피해 처리 순서를 검증
- 예:
    - Tank가 BodyBlock을 켠 상태에서, Monk가 아군에게 Shield + Valor를 걸어둔 상황
    - 적 공격이 들어왔을 때:
        - BodyBlock이 먼저 개입하는지
        - Shield → Valor → DEF 순서로 적용되는지
- 이 테스트가 없다면, 나중에 로직을 수정하면서 순서를 혼동할 가능성이 크다.

---

### 8.5 Enemy AI 계열 테스트

AI 쪽 테스트들은 이 프로젝트에서 가장 흥미로운 부분이었다.

하나하나가 "**AI가 이 상황에서는 이렇게 행동해야 한다**"는 명세서 역할을 한다.

### `EnemyAiStealthTest`

- **목적**: 은신(stealth)이 켜진 유닛에 대해 AI가 어떻게 반응해야 하는지 검증
- 시나리오:
    - 은신 유닛과 일반 유닛이 동시에 있을 때
        - AI는 은신 유닛을 무시하고, 보이는 유닛만 공격해야 한다.
    - 전장에 은신 유닛밖에 없을 때
        - AI는 아무 것도 하지 않고 턴을 넘겨야 한다.

### `EnemyAiStealthIgnoreTest`

- 조금 더 직접적으로:
    - 후보군에서 `isStealthed()` && !`isTaunting()` 유닛이 제외되는지
    - 단, 도발 중인 유닛이라면 스텔스라도 타겟이 될 수 있는지

### `EnemyAiTauntTest`

- **목적**: 도발(Taunt)이 켜져 있을 때 AI가 도발 대상을 우선시하는지 검증
- 시나리오:
    - 도발을 사용한 Tank와, 인접한 다른 아군이 있을 때
    - AI는 옆에 있는 "더 때리기 쉬운" 아군이 아니라,
        
        반드시 도발을 건 Tank를 향해 가거나 공격해야 한다.
        

### `EnemyAiTauntPriorityTest`

- Taunt + Stealth 조합까지 포함
    - Tank가 스텔스 상태이지만 도발을 걸었다면,
        
        은신이더라도 도발이 우선이라 타겟팅 가능해야 한다.
        
- 이 테스트는 "도발과 스텔스 중 어느 것이 우선인가?"를 명확히 정의해 준다.
    
    → 이 프로젝트에서는 **도발 > 스텔스** 로 결정했다.
    

### `EnemyAiFocusFireTest`

- **목적**: 한 Enemy 턴 안에서 적들이 "포커스 파이어(집중 공격)"를 하는지 검증
- 시나리오:
    - 두 적과 두 아군(힐러/딜러 포함)이 있을 때
    - 첫 번째 적이 힐러를 공격했다면,
        - 같은 Enemy Phase 내에서 두 번째 적도 가능한 한 같은 힐러를 공격해야 한다.
- 이 테스트 덕분에 "AI가 공격 타겟을 매번 랜덤으로 갈아타지 않고, 한 번 정한 타겟을 어느 정도 유지한다"는 규칙을 만들 수 있었다.

### `EnemyAiHealerPriorityTest`

- **목적**: 힐러/버퍼(MONK)를 우선 타겟으로 삼는 ThreatPolicy가 제대로 작동하는지 검증
- 시나리오:
    - 거리/조건이 거의 같은 MONK와 KNIGHT가 있을 때,
    - AI는 항상 MONK를 먼저 공격해야 한다.

### `EnemyAiDetourMoveTest`

- **목적**: 목표(TARGET)로 가는 길이 막혀 있을 때,
    
    blocker를 공격하는 대신 디툴(우회)하는지 검증
    
- 시나리오:
    - E(적)가 (2,1), Tank 아군이 (3,1), 타겟 MAGE가 (4,1)에 있을 때,
    - AI는 Tank를 공격해버리는 것이 아니라,
        - "목표는 뒤에 있는 MAGE"라고 판단하고
        - 직선이 막혔으면 위/아래로 돌아서 한 칸 이동해야 한다.
- 이 테스트 덕분에 "목표가 아닌 유닛은 공격하지 않는다"는 철학을 명확히 세울 수 있었다.

---

### 8.6 테스트가 설계에 준 영향

이 프로젝트에서 테스트는 단순히 "이 코드가 맞다/틀리다"를 판단하는 도구가 아니라,

- **도메인 규칙을 명시하는 문서**
- **설계가 바뀔 때 지켜야 하는 계약**
- **리팩터링 시 안심할 수 있게 해주는 안전망**

역할을 했다.

특히 AI/스킬/피로도/승리 조건처럼 사람 머리로만 따라가기 어려운 부분은,

테스트를 작성하는 과정에서 "**내가 진짜 원하는 규칙이 뭐지?**"를 거꾸로 더 명확하게 알게 되었다.

---

## 9. 앞으로 확장해보고 싶은 것들

이 프로젝트는 "끝난 게임"이기도 하지만,

동시에 "확장 가능한 실험장"이라고 생각하고 있다.

앞으로 시도해보고 싶은 것들

1. **GUI (Swing 또는 JavaFX)**
    - 현재 CLI 기반을 그대로 유지하면서
    - 화면만 GUI로 표현해보는 실험
    - MVC 구조를 더 명확하게 나누는 경험을 할 수 있을 것 같다.
2. **데이터 드리븐 설계**
    - 현재 Role/스탯/스킬이 모두 코드에 박혀있다.
    - JSON/YAML 등으로 유닛/스킬 정보를 외부화해서
        - 밸런스를 코드 수정 없이 조정 가능하게 만들고,
        - "새 직업 추가"를 더 쉽게 만들어보고 싶다.
3. **리플레이 기능**
    - 턴마다 발생하는 이벤트를 로그 구조로 기록해 두고,
    - 나중에 "텍스트 리플레이"나 "GUI 리플레이"로 재생하는 기능
4. **난이도 시스템**
    - Enemy AI의 공격성/위협 점수 가중치/리쿠르팅 빈도 등을 난이도로 묶어서,
    - Easy/Normal/Hard 모드 등을 만들어볼 수 있을 것 같다.

---

## 10. 마무리 – 이번 미션을 통해 얻은 것

이번 오픈 미션은 나에게 단순히

> "자바로 게임 하나 만들어봤다."
> 

가 아니라,

> "게임이라는 주제 안에서
> 
> 
> 자바, 설계, 테스트, 밸런싱, AI, 도메인 모델링을
> 
> 처음부터 끝까지 직접 경험했다."
> 

라는 의미가 있다.

- **중2 때 게임 모드로 시작한 프로그래밍 경험**이,
- **우테코 프리코스를 통해 처음 접한 자바**와 만나서,
- 하나의 작은 턴제 전략 게임이라는 형태로 연결되었다.

특히 기억에 남는 점은

- 설계를 여러 번 바꾸면서도
    
    테스트 덕분에 "겁먹지 않고" 리팩터링을 할 수 있었다는 것
    
- "왜 이렇게 설계했는지"를 말로 설명할 수 있을 정도로
    
    도메인/룰/코드를 고민했다는 것
    
- 단순 구현을 넘어,
    
    "플레이 경험"을 생각하면서 수치/룰/AI를 조정하려고 노력했다는 것

## 11. GamePlay Log

```text
. . . . . 
. . m . . 
. r . . . 
. . K A . 

=== UNIT STATUS ===
[PLAYER] 강철 수호자 레온   (KNIGHT) HP: 90 MP:  0  Pos:(2,3)  🛡 
[PLAYER] 새벽 사수 유리     (ARCHER) HP: 60 MP: 15  Pos:(4,3)  
[ENEMY ] 저주술사 모르가    (MAGE)   HP: 65 MP: 25  Pos:(2,1)  ✨ 
[ENEMY ] 암살자 니힐        (ROGUE)  HP: 60 MP: 10  Pos:(1,2)  

=== Turn 1 : PLAYER ===
행동할 아군 유닛 좌표 (예: 2,3) 또는 exit: 2,3
행동 (move / atk / skill): move
방향 (W/A/S/D): w

. . . . . 
. r m . . 
. . K . . 
. . . A . 

=== UNIT STATUS ===
[PLAYER] 강철 수호자 레온   (KNIGHT) HP: 90 MP:  0  Pos:(2,2)  
[PLAYER] 새벽 사수 유리     (ARCHER) HP: 60 MP: 15  Pos:(4,3)  
[ENEMY ] 저주술사 모르가    (MAGE)   HP: 65 MP: 25  Pos:(2,1)  ✨ 
[ENEMY ] 암살자 니힐        (ROGUE)  HP: 60 MP: 10  Pos:(1,1)  

=== Turn 1 : ENEMY ===
⚔️  암살자 니힐 → 강철 수호자 레온 공격! (남은 HP: 82)

. . . . . 
. r m . . 
. . K . . 
. . . A . 

=== UNIT STATUS ===
[PLAYER] 강철 수호자 레온   (KNIGHT) HP: 82 MP:  0  Pos:(2,2)  
[PLAYER] 새벽 사수 유리     (ARCHER) HP: 60 MP: 15  Pos:(4,3)  
[ENEMY ] 저주술사 모르가    (MAGE)   HP: 65 MP: 25  Pos:(2,1)  ✨ 
[ENEMY ] 암살자 니힐        (ROGUE)  HP: 60 MP: 10  Pos:(1,1)  

=== Turn 2 : PLAYER ===
행동할 아군 유닛 좌표 (예: 2,3) 또는 exit: 4,3
행동 (move / atk / skill): skill
사용할 스킬 번호를 선택하세요:
1) 파워 샷 (MP:5, CD:2)
번호: 1
스킬 대상 좌표 (예: x,y) / 자기대상 스킬은 Enter: 2,1
🏹  새벽 사수 유리 가 저주술사 모르가 에게 파워 샷을 사용했습니다! (남은 HP: 49)

=== Turn 2 : ENEMY ===
🔥  저주술사 모르가 가 화염구를 시전했습니다! (주변 적에게 피해)
⚔️  저주술사 모르가 → 강철 수호자 레온 공격! (남은 HP: 68)

. . . . . 
. r m . . 
. . K . . 
. . . A . 

=== UNIT STATUS ===
[PLAYER] 강철 수호자 레온   (KNIGHT) HP: 68 MP:  0  Pos:(2,2)  
[PLAYER] 새벽 사수 유리     (ARCHER) HP: 60 MP: 10  Pos:(4,3)  
[ENEMY ] 저주술사 모르가    (MAGE)   HP: 49 MP: 15  Pos:(2,1)  
[ENEMY ] 암살자 니힐        (ROGUE)  HP: 60 MP: 10  Pos:(1,1)  

=== Turn 3 : PLAYER ===
행동할 아군 유닛 좌표 (예: 2,3) 또는 exit: 2,2
행동 (move / atk / skill): skill
사용할 스킬 번호를 선택하세요:
1) 도발 (MP:0, CD:3)
번호: 1
스킬 대상 좌표 (예: x,y) / 자기대상 스킬은 Enter: 
🛡️  강철 수호자 레온 가 도발을 사용했습니다! (1턴 동안 적의 우선 타겟)

=== Turn 3 : ENEMY ===
⚔️  암살자 니힐 → 강철 수호자 레온 공격! (남은 HP: 60)
⚔️  저주술사 모르가 → 강철 수호자 레온 공격! (남은 HP: 52)

... (중략: 3턴 이후 리쿠르팅으로 수도승 "고요한 주먹 현우" 영입 및 배치) ...

=== UNIT STATUS ===
[PLAYER] 강철 수호자 레온   (KNIGHT) HP: 40 MP:  0  Pos:(2,2)  🛡 
[PLAYER] 새벽 사수 유리     (ARCHER) HP: 54 MP:  6  Pos:(4,3)  
[PLAYER] 고요한 주먹 현우   (MONK)   HP: 75 MP: 18  Pos:(1,3)  ✨ 💪
[ENEMY ] 저주술사 모르가    (MAGE)   HP: 30 MP: 10  Pos:(2,1)  
[ENEMY ] 암살자 니힐        (ROGUE)  HP: 42 MP:  6  Pos:(1,1)  🕶 

=== Turn 6 : PLAYER ===
행동할 아군 유닛 좌표 (예: 2,3) 또는 exit: 1,3
행동 (move / atk / skill): skill
사용할 스킬 번호를 선택하세요:
1) 보호막 (MP:6, CD:2)
2) 용기의 기도 (MP:8, CD:3)
번호: 1
스킬 대상 좌표 (예: x,y) / 자기대상 스킬은 Enter: 2,2
✨  고요한 주먹 현우 가 강철 수호자 레온 에게 보호막을 부여했습니다! (+12, 2턴)

=== Turn 6 : ENEMY ===
(스텔스 상태인 암살자 니힐은 타겟에서 제외됨)
⚔️  저주술사 모르가 → 강철 수호자 레온 공격! (보호막 흡수, 남은 HP: 40)
```